#!/usr/bin/env python3
"""Handles arguments from main shell function.

This is the core engine of the program. It handles all relevant options and
commands. After the arguments are parsed and handled, an output is printed to
the screen (but in practice this output is handled by the main shell function
and not necessarily printed to the screen).###########
"""
import os
import json
import pathlib
import argparse

# Can be changed to save the shellcuts in a different location.
D_SHELLCUTS = os.path.expanduser('~/.config/shellcuts/')
F_SHELLCUTS = 'shellcuts.json'
F_VERSION = '/usr/share/doc/shellcuts/META.txt'

### COMMANDS ###
def command_bashmarks():
    error_message(2)

def command_delete():
    shellcuts.pop(arguments.delete, None)
    write_shellcuts()
    print(":")

def command_go():
    try:
        shellcuts[arguments.shellcut]
        print("cd " + shellcuts[arguments.shellcut])
    except KeyError:
        error_message(1)

def command_help():
    print("man shellcuts")

def command_init():
    print("./sc-init")

def command_list():
    command = 'echo "SHELCUTS\n'
    for shellcut in shellcuts:
        command = command + '{0} : {1}\n'.format(
                                            shellcut,
                                            shellcuts[shellcut])
    command = command + '"'
    print(command)

def command_new():
    shellcuts[arguments.new] = os.getcwd()
    write_shellcuts()
    print(":")

def command_print():
    print("PRINT")
    try:
        print(arguments.print, ":", shellcuts[arguments.print])
    except KeyError:
        error_message(1)

def command_version():
    print("PRINT")
    [print(line) for line in load_version_info()]

def command_z():
    error_message(2)

### PARSER ###
def create_parser():
    """Create an argparse parser.

    Defines arguments and then returns the parser.
    """
    parser = argparse.ArgumentParser(add_help=False)
    
    parser.add_argument('shellcut', default=None, nargs='?')
    parser.add_argument('-d', '--delete')
    parser.add_argument('-h', '--help', action='store_true', default=None)
    parser.add_argument('-l', '--list', action='store_true', default=None)
    parser.add_argument('-n', '--new')
    parser.add_argument('-p', '--print')
    parser.add_argument('--version', action='store_true', default=None)
    parser.add_argument('--init', action='store_true', default=None)
    parser.add_argument('--enable-bashmarks-syntax',
                        action='store_true',
                        default=None,
                        dest='bashmarks')
    parser.add_argument('--disable-bashmarks-syntax',
                        action='store_false',
                        default=None,
                        dest='bashmarks')
    parser.add_argument('--enable-z',
                        action='store_true',
                        default=None,
                        dest='z')
    parser.add_argument('--disable-z',
                        action='store_false',
                        default=None,
                        dest='z')

    return parser

### ERROR HANDLING ###
def error_message(error):
    ERRORS = {1 : "That shellcut does not exist",
              2 : "This feature is unimplemented.",
              3 : "Version information not found."}
    print("echo \"ERROR {0}: {1}\"".format(error, ERRORS[error]))

### FILE I/O ###
def load_shellcuts():
    """Load the shellcuts file.

    Returns empty dictionary if the file does not exist.
    """
    try:
        with open(D_SHELLCUTS + F_SHELLCUTS, 'r') as f:
            shellcuts = json.load(f)
    except FileNotFoundError:
        shellcuts = {}

    return shellcuts

def load_version_info():
    """
    """
    try:
        with open(F_VERSION, 'r') as f:
            return f.readlines()
    except FileNotFoundError:
        error_message(3)
        return ''

def write_shellcuts():#
    """Write shellcuts to file.
    
    Creates appropriate directory if it doesn't exist.
    """
    if not pathlib.Path(D_SHELLCUTS).is_dir():
        pathlib.Path(D_SHELLCUTS).mkdir(parents=True)

    with open(D_SHELLCUTS + F_SHELLCUTS, 'w') as f:
        json.dump(shellcuts, f)

### START MAIN PROGRAM ###
parser = create_parser()
arguments = parser.parse_args()
shellcuts = load_shellcuts()

command_pairs = (
    (arguments.help, command_help),
    (arguments.list, command_list),
    (arguments.version, command_version),
    (arguments.init, command_init),
    (arguments.bashmarks, command_bashmarks),
    (arguments.z, command_z),
    (arguments.delete, command_delete),
    (arguments.new, command_new),
    (arguments.print, command_print),
    (arguments.shellcut, command_go))

for pair in command_pairs:
    if pair[0] != None:
        pair[1]()
