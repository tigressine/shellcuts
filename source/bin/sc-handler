#!/usr/bin/env python3
"""Handles arguments from main shell function.

This is the core engine of the program. It handles all relevant options and
commands. After the arguments are parsed and handled, an output is printed to
the screen (but in practice this output is handled by the main shell function
and not necessarily printed to the screen).###########
"""
import os
import json
import pathlib
import argparse

# FIX BEFORE 1.1.2
# Deal with split path name + ditch pathlib?
# Comment all functions + edit current comments
# Check all functions to make sure they work
# add docstring to test.sh and fix comments
# once over sc-init (most refactoring if necessary in 1.2
# remove shellcuts.sh and share?
# Check changes
# update meta
# update readme
# update man pages
# add docstring to make_deb + rename
# correct make deb configuration
# add docstring to postinst
# fix file i/o
# fix issue with argparse

### CONSTANTS ###
# Can be changed to save the shellcuts in a different location.
D_SHELLCUTS = os.path.expanduser('~/.config/shellcuts/')
F_SHELLCUTS = 'shellcuts.json'
F_VERSION = '/usr/share/doc/shellcuts/META.txt'


### COMMANDS ###
def command_bashmarks():
    error_message(2)

def command_delete():
    command = ':'
    shellcuts.pop(arguments.delete, None)
    write_shellcuts()
    print(command)

def command_go():
    try:
        command = 'cd ' + shellcuts[arguments.shellcut]
        print(command)
    except KeyError:
        error_message(1)

def command_help():
    command = 'man shellcuts'
    print(command)

def command_init():
    command = './sc-init'
    print(command)

def command_list():
    command = 'echo "SHELLCUTS\n'
    for shellcut in shellcuts:
        command += '{0} : {1}\n'.format(shellcut, shellcuts[shellcut])
    command = command[:-1] + '"'
    print(command)

def command_new():
    command = ':'
    shellcuts[arguments.new] = os.getcwd()
    write_shellcuts()
    print(command)

def command_print():
    try:
        command = 'echo "' + arguments.print + ' : ' + shellcuts[arguments.print] + '"'
        print(command)
    except KeyError:
        error_message(1)

def command_version():
    command = 'echo "'
    for line in load_version_info():
        command += line
    command += '"'
    print(command)

def command_z():
    error_message(2)


### HELPER FUNCTIONS ###
def create_parser():
    """Create an argparse parser.

    Defines arguments and then returns the parser.
    """
    parser = argparse.ArgumentParser(add_help=False)
    
    parser.add_argument('shellcut', default=None, nargs='?')
    parser.add_argument('-d', '--delete')
    parser.add_argument('-h', '--help', action='store_true', default=None)
    parser.add_argument('-l', '--list', action='store_true', default=None)
    parser.add_argument('-n', '--new')
    parser.add_argument('-p', '--print')
    parser.add_argument('--version', action='store_true', default=None)
    parser.add_argument('--init', action='store_true', default=None)
    parser.add_argument('--enable-bashmarks-syntax',
                        action='store_true',
                        default=None,
                        dest='bashmarks')
    parser.add_argument('--disable-bashmarks-syntax',
                        action='store_false',
                        default=None,
                        dest='bashmarks')
    parser.add_argument('--enable-z',
                        action='store_true',
                        default=None,
                        dest='z')
    parser.add_argument('--disable-z',
                        action='store_false',
                        default=None,
                        dest='z')

    return parser

def error_message(error):
    ERRORS = {1 : "That shellcut does not exist",
              2 : "This feature is unimplemented.",
              3 : "Version information not found."}
    print("echo \"ERROR {0}: {1}\"".format(error, ERRORS[error]))

def load_shellcuts():
    """Load the shellcuts file.

    Returns empty dictionary if the file does not exist.
    """
    try:
        with open(D_SHELLCUTS + F_SHELLCUTS, 'r') as f:
            shellcuts = json.load(f)
    except FileNotFoundError:
        shellcuts = {}

    return shellcuts

def load_version_info():
    """
    """
    try:
        with open(F_VERSION, 'r') as f:
            return f.readlines()
    except FileNotFoundError:
        error_message(3)##################
        return ''

def write_shellcuts():#
    """Write shellcuts to file.
    
    Creates appropriate directory if it doesn't exist.
    """
    if not pathlib.Path(D_SHELLCUTS).is_dir():
        pathlib.Path(D_SHELLCUTS).mkdir(parents=True)

    with open(D_SHELLCUTS + F_SHELLCUTS, 'w') as f:
        json.dump(shellcuts, f)


### START MAIN PROGRAM ###
parser = create_parser()
arguments = parser.parse_args()
shellcuts = load_shellcuts()

command_pairs = (
    (arguments.help, command_help),
    (arguments.list, command_list),
    (arguments.version, command_version),
    (arguments.init, command_init),
    (arguments.bashmarks, command_bashmarks),
    (arguments.z, command_z),
    (arguments.delete, command_delete),
    (arguments.new, command_new),
    (arguments.print, command_print),
    (arguments.shellcut, command_go))

for pair in command_pairs:
    if pair[0] != None:
        pair[1]()
