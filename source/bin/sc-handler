#!/usr/bin/env python3
"""Handles arguments from main shell function.

This is the core engine of the program. It handles all relevant options and
commands. After the arguments are parsed and handled, an output is printed to
the screen (but in practice this output is handled by the main shell function
and not necessarily printed to the screen).

Author: Tiger Sachse
License: GPLv3
Version: 1.1.2
Initial Release: 12/31/2017
Current Release: 01/16/2018
"""
import os
import json
import pathlib
import argparse

# Can be changed to save the shellcuts in a different location.
D_SHELLCUTS = os.path.expanduser('~/.config/shellcuts/')
F_SHELLCUTS = 'shellcuts.json'
VERSION_INFO = ['Shellcuts - Directory shortcuts for your shell.',
                'Author: Tiger Sachse',
                'License: GPLv3',
                'Version: 1.1.2',
                'Initial Release: 12/31/2017',
                'Current Release: 01/16/2018']

def error_message(error):
    ERRORS = {1 : "That shellcut does not exist",
              2 : "This feature is unimplemented."}
    print("ERROR {0}: {1}".format(error, ERRORS[error]))

### COMMANDS ###
def command_bashmarks():
    print("PRINT")
    error_message(2)

def command_delete():
    shellcuts.pop(arguments.delete, None)
    write_shellcuts()
    print("TERMINATE")

def command_go():
    try:
        shellcuts[arguments.shellcut]
        print("JUMP")
        print(shellcuts[arguments.shellcut])
    except KeyError:
        print("PRINT")
        error_message(1)

def command_help():
    print("PRINT")
    [print(line) for line in HELP_INFO]

def command_init():
    print("PRINT")
    error_message(2)

def command_list():
    print("PRINT")
    print("SHELLCUTS")
    for shellcut in shellcuts:
        print(shellcut, ":", shellcuts[shellcut])

def command_new():
    shellcuts[arguments.new] = os.getcwd()
    write_shellcuts()

def command_print():
    print("PRINT")
    try:
        print(arguments.print, ":", shellcuts[arguments.print])
    except KeyError:
        error_message(1)

def command_version():
    print("PRINT")
    [print(line) for line in VERSION_INFO]

def command_z():
    print("PRINT")
    error_message(2)

### PARSER ###
def create_parser():
    """Create an argparse parser.

    Defines arguments and then returns the parser.
    """
    parser = argparse.ArgumentParser(add_help=False)
    
    parser.add_argument('shellcut', default=None, nargs='?')
    parser.add_argument('-d', '--delete')
    parser.add_argument('-h', '--help', action='store_true', default=None)
    parser.add_argument('-l', '--list', action='store_true', default=None)
    parser.add_argument('-n', '--new')
    parser.add_argument('-p', '--print')
    parser.add_argument('--version', action='store_true', default=None)
    parser.add_argument('--init', action='store_true', default=None)
    parser.add_argument('--enable-bashmarks-syntax',
                        action='store_true',
                        default=None,
                        dest='bashmarks')
    parser.add_argument('--disable-bashmarks-syntax',
                        action='store_false',
                        default=None,
                        dest='bashmarks')
    parser.add_argument('--enable-z',
                        action='store_true',
                        default=None,
                        dest='z')
    parser.add_argument('--disable-z',
                        action='store_false',
                        default=None,
                        dest='z')

    return parser

### FILE I/O ###
def load_shellcuts():
    """Load the shellcuts file.

    Returns empty dictionary if the file does not exist.
    """
    try:
        with open(D_SHELLCUTS + F_SHELLCUTS, 'r') as f:
            shellcuts = json.load(f)
    except FileNotFoundError:
        shellcuts = {}

    return shellcuts

def write_shellcuts():#
    """Write shellcuts to file.
    
    Creates appropriate directory if it doesn't exist.
    """
    if not pathlib.Path(D_SHELLCUTS).is_dir():
        pathlib.Path(D_SHELLCUTS).mkdir(parents=True)

    with open(D_SHELLCUTS + F_SHELLCUTS, 'w') as f:
        json.dump(shellcuts, f)

### START MAIN PROGRAM ###
parser = create_parser()
arguments = parser.parse_args()
shellcuts = load_shellcuts()

command_pairs = (
    (arguments.help, command_help),
    (arguments.list, command_list),
    (arguments.version, command_version),
    (arguments.init, command_init),
    (arguments.bashmarks, command_bashmarks),
    (arguments.z, command_z),
    (arguments.delete, command_delete),
    (arguments.new, command_new),
    (arguments.print, command_print),
    (arguments.shellcut, command_go))

for pair in command_pairs:
    if pair[0] != None:
        pair[1]()
